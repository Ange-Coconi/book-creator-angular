// handleUnderlineEventNew() {
//     const selection = window.getSelection();
//     if (!selection || selection.rangeCount === 0) return;

//     const range = selection.getRangeAt(0);

//     // Helper function to check if a node or its ancestors have underline
//     const hasUnderlineStyle = (node: Node): boolean => {
//         let currentNode: Node | null = node;
//         while (currentNode) {
//             if (currentNode instanceof HTMLElement) {
//                 if (window.getComputedStyle(currentNode).textDecoration.includes('underline')) {
//                     return true;
//                 }
//             }
//             currentNode = currentNode.parentNode;
//         }
//         return false;
//     };

//     // Check if either the start or end containers or their ancestors have underline
//     const hasUnderlined = hasUnderlineStyle(range.startContainer) || hasUnderlineStyle(range.endContainer);

//     if (hasUnderlined && range.startContainer === range.endContainer && range.startContainer.nodeType === Node.TEXT_NODE) {
//         const textNode = range.startContainer;
//         const parentToRemove = textNode.parentNode as HTMLElement;
//         const parentOfParent = parentToRemove.parentElement;
                
//         if ((range.startOffset > 0 || range.endOffset < textNode.textContent!.length) && parentOfParent !== null) {
//             // Create three spans: before selection, selection, and after selection
//             if (range.startOffset > 0) {
//                 const beforeSpan = document.createElement('span');
//                 beforeSpan.style.textDecoration = 'underline';
//                 beforeSpan.textContent = textNode.textContent!.substring(0, range.startOffset);
//                 parentOfParent.insertBefore(beforeSpan, parentToRemove);
//             }

//             const selectionSpan = document.createElement('span');
//             selectionSpan.style.textDecoration = 'none';
//             selectionSpan.textContent = textNode.textContent!.substring(range.startOffset, range.endOffset);
//             parentOfParent.insertBefore(selectionSpan, parentToRemove);

//             if (range.endOffset < textNode.textContent!.length) {
//                 const afterSpan = document.createElement('span');
//                 afterSpan.style.textDecoration = 'underline';
//                 afterSpan.textContent = textNode.textContent!.substring(range.endOffset);
//                 parentOfParent.insertBefore(afterSpan, parentToRemove);
//             }
//             parentOfParent.removeChild(parentToRemove);
//             parentOfParent.normalize();

//             // parent.removeChild(textNode);
//             // parentOfParent?.removeChild(parent);
//             selection.removeAllRanges();
//             return;
//         }
//         if (parentToRemove.tagName === 'SPAN' && parentToRemove.style.textDecoration === 'underline') {
//             const parent = parentToRemove.parentNode;
//             if (parent) {
//                 while (parentToRemove.firstChild) {
//                     parent.insertBefore(parentToRemove.firstChild, parentToRemove);
//                 }
//                 parent.removeChild(parentToRemove);
//                 parent.normalize();
//             }
//             return;
//           }
//       }     

//     // Regular processing for other cases
//     const originalContent = range.cloneContents();
//     range.deleteContents();

//     const processNode = (node: Node): Node => {
//         if (node.nodeType === Node.TEXT_NODE) {
//             if (hasUnderlined) {
//                 return node.cloneNode(); // Simply clone text node, no span needed for removal
//             } else {
//                 const span = document.createElement('span');
//                 span.style.textDecoration = 'underline';
//                 span.appendChild(node.cloneNode());
//                 return span;
//             }
//         }

//         if (node instanceof HTMLElement) {
//             if (node.tagName === 'SPAN' && node.style.textDecoration === 'underline' && hasUnderlined) {
//                 // Remove underline spans
//                 const fragment = document.createDocumentFragment();
//                 node.childNodes.forEach(child => {
//                     fragment.appendChild(processNode(child));
//                 });
//                 return fragment;
//             } else if (!hasUnderlined) {
//                 // Wrap in a span with underline if not already underlined
//                 const span = document.createElement('span');
//                 span.style.textDecoration = 'underline';
//                 span.textContent = node.textContent;
//                 return span;
//             }
//         }

//         return node.cloneNode(true);
//     };

//     const newFragment = document.createDocumentFragment();
//     originalContent.childNodes.forEach(node => {
//         newFragment.appendChild(processNode(node));
//     });

//     range.insertNode(newFragment);
//     // Normalize the parent container to clean up text nodes
//     const editor = document.getElementById('editor'); // Assuming 'editor' is the container
//     if (editor) {
//         editor.normalize();
//     }
//     selection.removeAllRanges();

    
// }

// handleUnderlineEvent() {
//     const selection = window.getSelection();
//     if (!selection || selection.rangeCount === 0) return;

//     const range = selection.getRangeAt(0);

//     // Helper function to check if a node or its ancestors have underline
//     const hasUnderlineStyle = (node: Node): boolean => {
//         let currentNode: Node | null = node;
//         while (currentNode) {
//             if (currentNode instanceof HTMLElement) {
//                 if (window.getComputedStyle(currentNode).textDecoration.includes('underline')) {
//                     return true;
//                 }
//             }
//             currentNode = currentNode.parentNode;
//         }
//         return false;
//     };

//     // Check if either the start or end containers or their ancestors have underline
//     const hasUnderlined = hasUnderlineStyle(range.startContainer) || hasUnderlineStyle(range.endContainer);

//     if (hasUnderlined && range.startContainer === range.endContainer && range.startContainer.nodeType === Node.TEXT_NODE) {
//         const textNode = range.startContainer;
//         const parentToRemove = textNode.parentNode as HTMLElement;
//         const parentOfParent = parentToRemove.parentElement;
                
//         if ((range.startOffset > 0 || range.endOffset < textNode.textContent!.length) && parentOfParent !== null) {
//             // Create three spans: before selection, selection, and after selection
//             if (range.startOffset > 0) {
//                 const beforeSpan = document.createElement('span');
//                 beforeSpan.style.textDecoration = 'underline';
//                 beforeSpan.textContent = textNode.textContent!.substring(0, range.startOffset);
//                 parentOfParent.insertBefore(beforeSpan, parentToRemove);
//             }

//             const selectionSpan = document.createElement('span');
//             selectionSpan.style.textDecoration = 'none';
//             selectionSpan.textContent = textNode.textContent!.substring(range.startOffset, range.endOffset);
//             parentOfParent.insertBefore(selectionSpan, parentToRemove);

//             if (range.endOffset < textNode.textContent!.length) {
//                 const afterSpan = document.createElement('span');
//                 afterSpan.style.textDecoration = 'underline';
//                 afterSpan.textContent = textNode.textContent!.substring(range.endOffset);
//                 parentOfParent.insertBefore(afterSpan, parentToRemove);
//             }
//             parentOfParent.removeChild(parentToRemove);
//             parentOfParent.normalize();

//             // parent.removeChild(textNode);
//             // parentOfParent?.removeChild(parent);
//             selection.removeAllRanges();
//             return;
//         }
//         if (parentToRemove.tagName === 'SPAN' && parentToRemove.style.textDecoration === 'underline') {
//             const parent = parentToRemove.parentNode;
//             if (parent) {
//                 while (parentToRemove.firstChild) {
//                     parent.insertBefore(parentToRemove.firstChild, parentToRemove);
//                 }
//                 parent.removeChild(parentToRemove);
//                 parent.normalize();
//             }
//             return;
//           }
//       }     

//     // Regular processing for other cases
//     const originalContent = range.cloneContents();
//     range.deleteContents();

//     const processNode = (node: Node): Node => {
//         if (node.nodeType === Node.TEXT_NODE) {
//             if (hasUnderlined) {
//                 return node.cloneNode(); // Simply clone text node, no span needed for removal
//             } else {
//                 const span = document.createElement('span');
//                 span.style.textDecoration = 'underline';
//                 span.appendChild(node.cloneNode());
//                 return span;
//             }
//         }

//         if (node instanceof HTMLElement) {
//             if (node.tagName === 'SPAN' && node.style.textDecoration === 'underline' && hasUnderlined) {
//                 // Remove underline spans
//                 const fragment = document.createDocumentFragment();
//                 node.childNodes.forEach(child => {
//                     fragment.appendChild(processNode(child));
//                 });
//                 return fragment;
//             } else if (!hasUnderlined) {
//                 // Wrap in a span with underline if not already underlined
//                 const span = document.createElement('span');
//                 span.style.textDecoration = 'underline';
//                 span.textContent = node.textContent;
//                 return span;
//             }
//         }

//         return node.cloneNode(true);
//     };

//     const newFragment = document.createDocumentFragment();
//     originalContent.childNodes.forEach(node => {
//         newFragment.appendChild(processNode(node));
//     });

//     range.insertNode(newFragment);
//     // Normalize the parent container to clean up text nodes
//     const editor = document.getElementById('editor'); // Assuming 'editor' is the container
//     if (editor) {
//         editor.normalize();
//     }
//     selection.removeAllRanges();

    
// }
